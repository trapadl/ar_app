


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Bar Race AR Challenge</title>

    <!-- Supabase Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <!-- A-Frame Core -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <!-- AR.js for A-Frame (including location-based) -->
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
    <!-- Location Based AR component for AR.js -->
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/three.js/build/ar-threex-location-only.js"></script>


    <style>
        /* Basic Reset & Body */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { height: 100%; }
        body {
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            color: #333;
            overflow: hidden; /* Prevent scrolling page behind UI */
            background-color: #000; /* Fallback background */
        }

        /* A-Frame Scene should be behind UI */
        #ar-scene {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* UI Overlay Panels */
        .ui-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.95); /* Slightly transparent background */
            z-index: 10; /* Above AR scene */
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            justify-content: center; /* Center content vertically */
            padding: 20px;
            text-align: center;
            overflow-y: auto; /* Allow scrolling if content overflows */
        }
        .ui-panel.active {
            display: flex;
        }

        /* Specific panel for race UI (transparent background) */
        #ui-panel-race {
            background-color: transparent;
            justify-content: flex-start; /* Align race UI to top */
            pointer-events: none; /* Allow clicks to pass through background */
            padding: 0; /* Remove padding */
        }
        #ui-panel-race > * {
             pointer-events: auto; /* Re-enable pointer events for children */
        }

        /* Race UI Elements (positioned over camera view) */
        #race-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 11;
            pointer-events: auto; /* Ensure clicks work if needed later */
        }
         #race-info p { margin-bottom: 5px; }

        /* Compass Overlay */
        #compass-overlay {
            position: absolute;
            bottom: 15px;
            left: 15px;
            width: 60px;
            height: 60px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
            z-index: 11;
            display: flex; /* Use flex for centering arrow */
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }
        #compass-overlay-arrow {
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 30px solid #e74c3c; /* Red arrow pointing up initially */
            transform-origin: 50% 100%; /* Rotate around bottom center */
            transition: transform 0.2s linear;
        }
        #compass-overlay-north {
            position: absolute;
            top: -15px; /* Position above the circle */
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 10px;
            font-weight: bold;
        }

        /* Common UI Elements Styling */
        h1, h2 { margin-bottom: 15px; color: #333; }
        p { margin-bottom: 10px; line-height: 1.5; }
        button {
            display: inline-block;
            background-color: #007bff;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 10px;
            margin-bottom: 10px;
            transition: background-color 0.2s ease;
            width: 80%;
            max-width: 300px;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        input[type="text"], input[type="email"], input[type="password"] {
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 80%;
            max-width: 300px;
            font-size: 16px;
        }
        .error-message { color: #dc3545; margin-top: 5px; font-weight: bold; font-size: 14px;}
        .info-message { color: #17a2b8; margin-top: 5px; font-size: 14px;}
        .success-message { color: #28a745; margin-top: 5px; font-weight: bold; font-size: 14px;}

        #leaderboard-container {
            margin-top: 15px;
            width: 90%;
            max-width: 400px;
            max-height: 50vh;
            overflow-y: auto;
            border: 1px solid #eee;
            background-color: #fff; /* Ensure it's opaque */
        }
        #leaderboard-table { width: 100%; border-collapse: collapse; }
        #leaderboard-table th, #leaderboard-table td { border: 1px solid #ddd; padding: 6px; text-align: left; font-size: 14px; }
        #leaderboard-table th { background-color: #f2f2f2; position: sticky; top: 0; z-index: 1; }
         #leaderboard-table td:nth-child(1), #leaderboard-table th:nth-child(1) { width: 15%; }
         #leaderboard-table td:nth-child(3), #leaderboard-table th:nth-child(3) { width: 25%; }

         /* Admin Waypoint List */
         #admin-waypoints-list { list-style: none; padding: 0; text-align: left; max-height: 150px; overflow-y: auto; border: 1px solid #eee; margin-top: 10px; margin-bottom: 10px; width: 90%; background: #fff; }
         #admin-waypoints-list li { padding: 5px; border-bottom: 1px solid #eee; font-size: 12px; }

         /* Loading Indicator */
         #loading-indicator {
             /* Style a loading spinner or message if needed */
             color: white;
             font-size: 18px;
             background-color: rgba(0,0,0,0.8);
             padding: 15px;
             border-radius: 8px;
         }

         /* Debug Info (Optional) */
         #debug-info {
             position: absolute;
             bottom: 10px;
             right: 10px;
             font-size: 10px;
             color: yellow;
             background: rgba(0,0,0,0.5);
             padding: 3px;
             z-index: 20;
             display: none; /* Hidden by default */
         }
    </style>
</head>
<body>
    <!-- A-Frame Scene: Renders Camera and AR Content -->
    <!-- `embedded` makes it fit the flow; CSS positions it absolutely -->
    <!-- `renderer` settings for performance/appearance -->
    <!-- `arjs` basic setup; `detectionMode` might need tuning -->
    <a-scene
        id="ar-scene"
        embedded
        renderer="logarithmicDepthBuffer: true; precision: medium; antialias: true; alpha: true;"
        vr-mode-ui="enabled: false"
        arjs="sourceType: webcam; trackingMethod: best; debugUIEnabled: false; changeMatrixMode: modelViewMatrix; detectionMode: mono_and_matrix; matrixCodeType: 3x3;">

        <!-- AR Camera linked to GPS -->
        <!-- `gpsMinDistance`: How many meters user must move before camera position updates -->
        <a-camera id="ar-camera" gps-new-camera="gpsMinDistance: 5"></a-camera>

        <!-- Container for dynamically added waypoints -->
        <a-entity id="waypoints-container"></a-entity>

    </a-scene>

    <!-- HTML UI Overlay Panels -->

    <!-- Loading/Permission Panel -->
    <div id="ui-panel-loading" class="ui-panel active">
        <div id="loading-indicator">Initializing AR...</div>
        <p id="permissions-info" class="info-message" style="margin-top: 15px;">Waiting for Camera and Location permissions...</p>
        <button id="btn-force-start" style="display: none; background-color: #ffc107; color: black;">Tap to Start Camera (if needed)</button>
        <p id="loading-error" class="error-message"></p>
    </div>

    <!-- Landing Panel -->
    <div id="ui-panel-landing" class="ui-panel">
        <h1>Welcome to the Bar Race AR!</h1>
        <p>Follow the AR markers from the back door to the front.</p>
        <button id="btn-start-user">Start Race</button>
        <button id="btn-admin" style="background-color: #6c757d;">Admin</button>
    </div>

    <!-- Admin Login Panel -->
    <div id="ui-panel-admin-login" class="ui-panel">
        <h2>Admin Access</h2>
        <label for="admin-code">Enter 4-Digit Code:</label>
        <input type="password" id="admin-code" inputmode="numeric" pattern="[0-9]*" maxlength="4">
        <button id="btn-admin-submit">Login</button>
        <button id="btn-admin-back" style="background-color: #6c757d;">Back</button>
        <p id="admin-login-error" class="error-message"></p>
    </div>

    <!-- Admin Record Panel -->
    <div id="ui-panel-admin-record" class="ui-panel">
        <h2>Record Trail Waypoints (AR)</h2>
        <p>Walk the route and press "Record Waypoint" at key points.</p>
        <button id="btn-record-waypoint">Record Waypoint</button>
        <label for="waypoint-label">Optional Label:</label>
        <input type="text" id="waypoint-label" placeholder="e.g., First Corner">
        <ul id="admin-waypoints-list"></ul>
        <p id="admin-record-status" class="info-message"></p>
        <button id="btn-save-trail" disabled>Save Trail to Supabase</button>
        <button id="btn-record-back" style="background-color: #6c757d;">Back to Landing</button>
    </div>

    <!-- Race UI (Overlay during race) -->
    <div id="ui-panel-race" class="ui-panel">
        <div id="race-info">
            <p>Time: <span id="race-timer">0.0</span>s</p>
            <p>Next: <strong id="next-waypoint-label">Loading...</strong></p>
            <p>Distance: <span id="distance-to-waypoint">---</span> m</p>
            <p id="race-status" class="info-message"></p>
        </div>
        <div id="compass-overlay">
            <div id="compass-overlay-north">N</div>
            <div id="compass-overlay-arrow"></div>
        </div>
    </div>

    <!-- Finish Panel (Prompt 1) -->
    <div id="ui-panel-finish" class="ui-panel">
        <h2>You've Arrived!</h2>
        <p>Final time: <strong id="final-time">0.0</strong> seconds!</p>
        <p>Want to join the leaderboard?</p>
        <label for="user-name">Name:</label>
        <input type="text" id="user-name" placeholder="Your Name">
        <label for="user-email">Email:</label>
        <input type="email" id="user-email" placeholder="your.email@example.com">
        <button id="btn-join-leaderboard">Join Leaderboard</button>
        <button id="btn-skip-prompt1" style="background-color: #6c757d;">Skip</button>
        <p id="leaderboard-submit-status" class="info-message"></p>
    </div>

     <!-- Discount Prompt Panel (Prompt 2) -->
     <div id="ui-panel-discount-prompt" class="ui-panel">
         <h2>Wait! Get 10% Off!</h2>
         <p>Join the leaderboard and get a 10% discount voucher for Trap!</p>
         <label for="user-name-discount">Name:</label>
         <input type="text" id="user-name-discount" placeholder="Your Name">
         <label for="user-email-discount">Email:</label>
         <input type="email" id="user-email-discount" placeholder="your.email@example.com">
         <button id="btn-join-leaderboard-discount">Join & Get Discount</button>
         <button id="btn-skip-prompt2" style="background-color: #6c757d;">No Thanks</button>
         <p id="leaderboard-submit-status-discount" class="info-message"></p>
     </div>

    <!-- Final Leaderboard Panel -->
    <div id="ui-panel-final-leaderboard" class="ui-panel">
        <h2 id="final-message">Thanks for playing!</h2>
        <h3>Top Times</h3>
        <div id="leaderboard-container">
            <table id="leaderboard-table">
                <thead> <tr><th>Rank</th><th>Name</th><th>Time (s)</th></tr> </thead>
                <tbody id="leaderboard-body"><tr><td colspan="3">Loading...</td></tr></tbody>
            </table>
        </div>
         <button id="btn-play-again" style="margin-top: 20px;">Play Again</button>
    </div>

    <!-- Error Panel -->
    <div id="ui-panel-error" class="ui-panel">
         <h2>Oops! Something went wrong.</h2>
         <p id="error-details">An error occurred.</p>
         <button id="btn-error-back">Go Back to Start</button>
    </div>

     <!-- Debug Info Display -->
    <div id="debug-info">Debug: ...</div>

    <script>
        /*****************************************
         *           CONFIGURATION               *
         *****************************************/
         const SUPABASE_URL = "https://hdagjajchjxsyytdlqzi.supabase.co"; // <-- REPLACE THIS
        const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhkYWdqYWpjaGp4c3l5dGRscXppIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDMyOTE3NjEsImV4cCI6MjA1ODg2Nzc2MX0.8A5dhEKfDbUOeouvp_e32rMR-NUwnUjBTuP-8tEtsYU"; // <-- REPLACE THIS
        const ADMIN_CODE = "9090";
        const WAYPOINT_PROXIMITY_THRESHOLD = 10; // Meters - How close user needs to be
        const LEADERBOARD_LIMIT = 20;
        const WAYPOINT_SCALE = "1.5 1.5 1.5"; // Size of AR waypoint markers
        const WAYPOINT_COLOR = "#FF5733"; // Color of AR waypoint markers
        const SHOW_DEBUG_INFO = false; // Set to true to see lat/lon/heading

        /*****************************************
         *        DOM ELEMENT REFERENCES         *
         *****************************************/
        const arScene = document.getElementById('ar-scene');
        const arCamera = document.getElementById('ar-camera');
        const waypointsContainer = document.getElementById('waypoints-container');
        const uiPanels = {
            loading: document.getElementById('ui-panel-loading'),
            landing: document.getElementById('ui-panel-landing'),
            adminLogin: document.getElementById('ui-panel-admin-login'),
            adminRecord: document.getElementById('ui-panel-admin-record'),
            race: document.getElementById('ui-panel-race'), // Overlay during race
            finish: document.getElementById('ui-panel-finish'),
            discountPrompt: document.getElementById('ui-panel-discount-prompt'),
            finalLeaderboard: document.getElementById('ui-panel-final-leaderboard'),
            error: document.getElementById('ui-panel-error')
        };
        const loadingIndicator = document.getElementById('loading-indicator');
        const permissionsInfo = document.getElementById('permissions-info');
        const loadingError = document.getElementById('loading-error');
        const btnForceStart = document.getElementById('btn-force-start');
        // Landing
        const btnStartUser = document.getElementById('btn-start-user');
        const btnAdmin = document.getElementById('btn-admin');
        // Admin Login
        const adminCodeInput = document.getElementById('admin-code');
        const btnAdminSubmit = document.getElementById('btn-admin-submit');
        const btnAdminBack = document.getElementById('btn-admin-back');
        const adminLoginError = document.getElementById('admin-login-error');
        // Admin Record
        const btnRecordWaypoint = document.getElementById('btn-record-waypoint');
        const waypointLabelInput = document.getElementById('waypoint-label');
        const adminWaypointsList = document.getElementById('admin-waypoints-list');
        const adminRecordStatus = document.getElementById('admin-record-status');
        const btnSaveTrail = document.getElementById('btn-save-trail');
        const btnRecordBack = document.getElementById('btn-record-back');
        // Race UI
        const raceInfo = document.getElementById('race-info');
        const raceTimerDisplay = document.getElementById('race-timer');
        const nextWaypointLabelDisplay = document.getElementById('next-waypoint-label');
        const distanceDisplay = document.getElementById('distance-to-waypoint');
        const raceStatus = document.getElementById('race-status');
        const compassOverlayArrow = document.getElementById('compass-overlay-arrow');
        // Finish
        const finalTimeDisplay = document.getElementById('final-time');
        const userNameInput = document.getElementById('user-name');
        const userEmailInput = document.getElementById('user-email');
        const btnJoinLeaderboard = document.getElementById('btn-join-leaderboard');
        const btnSkipPrompt1 = document.getElementById('btn-skip-prompt1');
        const leaderboardSubmitStatus = document.getElementById('leaderboard-submit-status');
        // Discount
        const userNameDiscountInput = document.getElementById('user-name-discount');
        const userEmailDiscountInput = document.getElementById('user-email-discount');
        const btnJoinLeaderboardDiscount = document.getElementById('btn-join-leaderboard-discount');
        const btnSkipPrompt2 = document.getElementById('btn-skip-prompt2');
        const leaderboardSubmitStatusDiscount = document.getElementById('leaderboard-submit-status-discount');
        // Final Leaderboard
        const finalMessage = document.getElementById('final-message');
        const leaderboardBody = document.getElementById('leaderboard-body');
        const btnPlayAgain = document.getElementById('btn-play-again');
        // Error
        const errorDetails = document.getElementById('error-details');
        const btnErrorBack = document.getElementById('btn-error-back');
        // Debug
        const debugInfo = document.getElementById('debug-info');


        /*****************************************
         *           APPLICATION STATE           *
         *****************************************/
        let supabaseClient = null;
        let currentPanel = 'loading';
        let isAdmin = false;
        let recordedWaypoints = [];
        let trailWaypoints = []; // Array of { lat, lon, label } AND associated <a-entity>
        let currentWaypointIndex = 0;
        let userLocation = null; // { latitude, longitude, accuracy } from GPS
        let userHeading = null; // Degrees from North from DeviceOrientation
        let startTime = null;
        let endTime = null;
        let finalTimeSeconds = 0;
        let timerInterval = null;
        let watchId = null; // Geolocation watch ID
        let orientationListener = null;
        let locationErrorCount = 0;
        const MAX_LOCATION_ERRORS = 5; // Give up after 5 consecutive errors

        /*****************************************
         *         INITIALIZATION & PERMS        *
         *****************************************/

        function initializeApp() {
             // Show debug info if enabled
             debugInfo.style.display = SHOW_DEBUG_INFO ? 'block' : 'none';

            if (!checkPrerequisites()) return;
            if (!initializeSupabase()) return;

            // Request permissions sequentially
            requestCameraPermission()
                .then(() => requestLocationPermission())
                .then(() => requestOrientationPermission()) // Request orientation after others
                .then(() => {
                    console.log("All permissions seem granted or handled.");
                    permissionsInfo.textContent = "Permissions OK. Ready.";
                    loadingIndicator.textContent = "Ready";
                    showPanel('landing'); // Move to landing page
                    startOrientationListener(); // Start listening for compass
                })
                .catch(error => {
                    console.error("Permission sequence error:", error);
                    showErrorPanel(`Initialization failed: ${error.message}`);
                });

             // Some browsers require user interaction to start video
             btnForceStart.addEventListener('click', () => {
                const video = document.querySelector('video');
                if (video && video.paused) {
                    video.play().catch(e => console.error("Force play failed:", e));
                }
                btnForceStart.style.display = 'none';
             });
             // Show force start button if video doesn't play automatically after a delay
             setTimeout(() => {
                 const video = document.querySelector('video');
                 if (video && video.paused) {
                     console.log("Camera video seems paused, showing manual start button.");
                     btnForceStart.style.display = 'block';
                 }
             }, 5000); // 5 seconds delay
        }

        function checkPrerequisites() {
            if (typeof AFRAME === 'undefined') {
                showErrorPanel("A-Frame library not loaded. Cannot start AR.");
                return false;
            }
             if (typeof THREEx === 'undefined' || !THREEx.LocationBased) {
                showErrorPanel("AR.js Location-Based library not loaded. Cannot start AR.");
                return false;
             }
            if (!navigator.geolocation) {
                showErrorPanel("Geolocation is not supported by this browser.");
                return false;
            }
             if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                 showErrorPanel("Camera access (getUserMedia) is not supported by this browser.");
                 return false;
             }
            console.log("Prerequisites check passed.");
            return true;
        }

        function initializeSupabase() {
             if (!SUPABASE_URL || !SUPABASE_ANON_KEY || SUPABASE_URL.includes("YOUR_PROJECT") || SUPABASE_ANON_KEY.includes("YOUR_ANON")) {
                 console.error("Supabase credentials missing.");
                 showErrorPanel("Application Error: Supabase credentials missing.");
                 return false;
            }
            if (typeof supabase === 'undefined' || !supabase.createClient) {
                 console.error("Supabase library not loaded.");
                 showErrorPanel("Application Error: Supabase library failed to load.");
                 return false;
            }
            try {
                 supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                 console.log("Supabase client initialized.");
                 return true;
            } catch (error) {
                 console.error("Supabase initialization error:", error);
                 showErrorPanel(`Database connection failed: ${error.message}`);
                 return false;
            }
        }

         // Promise-based permission requests
         function requestCameraPermission() {
            return new Promise((resolve, reject) => {
                 permissionsInfo.textContent = "Requesting Camera access...";
                 navigator.mediaDevices.getUserMedia({ video: true })
                    .then(stream => {
                        console.log("Camera permission granted.");
                        // We don't need to keep the stream, AR.js handles it. Stop tracks to release camera immediately.
                        stream.getTracks().forEach(track => track.stop());
                        permissionsInfo.textContent = "Camera OK.";
                        resolve();
                    })
                    .catch(error => {
                         console.error("Camera permission error:", error);
                         permissionsInfo.textContent = "Camera permission denied or error.";
                         reject(new Error("Camera permission denied. The AR experience requires camera access."));
                    });
            });
         }

         function requestLocationPermission() {
             return new Promise((resolve, reject) => {
                 permissionsInfo.textContent = "Requesting Location access...";
                 navigator.geolocation.getCurrentPosition(
                    (position) => {
                        console.log("Location permission granted.");
                        permissionsInfo.textContent = "Camera OK. Location OK.";
                        userLocation = position.coords; // Store initial location
                        resolve();
                    },
                    (error) => {
                        console.error("Location permission error:", error);
                        permissionsInfo.textContent = "Location permission denied or error.";
                         if (error.code === 1) reject(new Error("Location permission denied. The race requires GPS access."));
                         else reject(new Error(`Location error: ${error.message}`));
                    },
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
                 );
             });
         }

         function requestOrientationPermission() {
            return new Promise((resolve) => { // Resolve even if denied/unsupported
                 permissionsInfo.textContent = "Checking Motion/Orientation access...";
                 if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                     // iOS 13+ requires explicit permission
                     DeviceOrientationEvent.requestPermission()
                         .then(permissionState => {
                             if (permissionState === 'granted') {
                                 console.log("DeviceOrientation permission granted.");
                                 permissionsInfo.textContent += " Orientation OK.";
                             } else {
                                 console.warn("DeviceOrientation permission denied.");
                                 permissionsInfo.textContent += " Orientation denied (compass may not work).";
                             }
                             resolve(); // Resolve regardless of grant state
                         })
                         .catch(error => {
                             console.error("DeviceOrientation request error:", error);
                             permissionsInfo.textContent += " Orientation check error.";
                             resolve(); // Still resolve
                         });
                 } else {
                     // Non-iOS 13+ or unsupported devices
                     console.log("DeviceOrientation permission not required or not supported.");
                     permissionsInfo.textContent += " Orientation OK (or not needed).";
                     resolve(); // Assume available or not needed
                 }
            });
        }


        /*****************************************
         *          UI / Panel Management        *
         *****************************************/
        function showPanel(panelName) {
            console.log("Showing panel:", panelName);
            Object.values(uiPanels).forEach(panel => panel.classList.remove('active'));
            if (uiPanels[panelName]) {
                uiPanels[panelName].classList.add('active');
                currentPanel = panelName;
            } else {
                console.error("Panel not found:", panelName);
                uiPanels.landing.classList.add('active'); // Fallback
                currentPanel = 'landing';
            }
            // Pause/Resume AR Scene based on panel? (Optional optimization)
            // const scene = document.querySelector('a-scene');
            // if (panelName === 'race') scene.play(); else scene.pause();
        }

        function showErrorPanel(message) {
            stopAllActivity(); // Stop timers, sensors etc.
            errorDetails.textContent = message;
            showPanel('error');
        }


        /*****************************************
         *            ADMIN FUNCTIONS            *
         *****************************************/
        // handleAdminClick, handleAdminLogin, updateAdminWaypointList, handleSaveTrail
        // are mostly identical to the previous version, just ensure they use
        // supabaseClient and update the correct UI elements (adminRecordStatus etc.)
        // handleRecordWaypoint is also the same (uses navigator.geolocation)

        function handleAdminClick() {
            adminCodeInput.value = '';
            adminLoginError.textContent = '';
            showPanel('adminLogin');
        }

        function handleAdminLogin() {
            const code = adminCodeInput.value;
            if (code === ADMIN_CODE) {
                isAdmin = true;
                recordedWaypoints = [];
                updateAdminWaypointList();
                adminRecordStatus.textContent = '';
                btnSaveTrail.disabled = true;
                showPanel('adminRecord');
            } else {
                adminLoginError.textContent = "Invalid code.";
            }
        }

         function handleRecordWaypoint() {
            const label = waypointLabelInput.value.trim();
            adminRecordStatus.textContent = "Getting location...";
            btnRecordWaypoint.disabled = true;

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const newWaypoint = {
                        lat: position.coords.latitude,
                        lon: position.coords.longitude,
                        label: label || `Waypoint ${recordedWaypoints.length + 1}`
                    };
                    recordedWaypoints.push(newWaypoint);
                    updateAdminWaypointList();
                    waypointLabelInput.value = '';
                    adminRecordStatus.textContent = `Waypoint ${recordedWaypoints.length} recorded (Acc: ${position.coords.accuracy.toFixed(1)}m).`;
                    btnSaveTrail.disabled = recordedWaypoints.length > 0;
                    btnRecordWaypoint.disabled = false;
                },
                (error) => {
                    console.error("Admin Geolocation error:", error);
                    adminRecordStatus.textContent = `Error getting location: ${error.message}`;
                    btnRecordWaypoint.disabled = false;
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        }

        function updateAdminWaypointList() {
            adminWaypointsList.innerHTML = '';
            if (recordedWaypoints.length === 0) {
                adminWaypointsList.innerHTML = '<li>No waypoints recorded yet.</li>';
            } else {
                recordedWaypoints.forEach((wp, index) => {
                    const li = document.createElement('li');
                    li.textContent = `${index + 1}: ${wp.label} (${wp.lat.toFixed(6)}, ${wp.lon.toFixed(6)})`;
                    adminWaypointsList.appendChild(li);
                });
            }
        }

         async function handleSaveTrail() {
            if (recordedWaypoints.length === 0) return;
            if (!supabaseClient) { showErrorPanel("Database connection lost."); return; }

            btnSaveTrail.disabled = true;
            adminRecordStatus.textContent = "Saving trail...";

            try {
                let { data: existingTrails, error: fetchError } = await supabaseClient
                    .from('trails').select('id').limit(1);
                if (fetchError) throw fetchError;

                const trailData = { name: 'Bar Trail AR', waypoints: recordedWaypoints };
                let result;

                if (existingTrails && existingTrails.length > 0) {
                    const { data, error } = await supabaseClient
                        .from('trails').update(trailData).eq('id', existingTrails[0].id).select();
                    if (error) throw error; result = data;
                } else {
                     const { data, error } = await supabaseClient
                        .from('trails').insert([trailData]).select();
                     if (error) throw error; result = data;
                }
                 console.log("Save trail result:", result);
                 adminRecordStatus.textContent = `Trail saved! (${recordedWaypoints.length} waypoints)`;
                 recordedWaypoints = [];
                 updateAdminWaypointList();
                 // Keep save disabled until new waypoints added
            } catch (error) {
                console.error("Error saving trail:", error);
                adminRecordStatus.textContent = `Error saving trail: ${error.message}`;
                btnSaveTrail.disabled = recordedWaypoints.length === 0;
            }
        }


        /*****************************************
         *         USER RACE FUNCTIONS           *
         *****************************************/

         function handleStartUserMode() {
            isAdmin = false;
             // Reset potential stale data from previous attempts
            trailWaypoints = [];
            currentWaypointIndex = 0;
            finalTimeSeconds = 0;
            locationErrorCount = 0;
            // Clear any previously created AR entities
            waypointsContainer.innerHTML = '';

            // Check if location is available (might have been denied earlier)
             if (!userLocation) {
                 showErrorPanel("Initial location not available. Please ensure location services are enabled and permission granted, then reload.");
                 return;
             }

            // Fetch trail and then start
            fetchTrailAndStartAR();
        }

        async function fetchTrailAndStartAR() {
            if (!supabaseClient) { showErrorPanel("Database connection lost."); return; }

             // Show race UI overlay immediately but indicate loading
             showPanel('race');
             raceStatus.textContent = "Loading trail...";
             nextWaypointLabelDisplay.textContent = "Loading...";
             distanceDisplay.textContent = "---";

            try {
                let { data, error } = await supabaseClient
                    .from('trails').select('waypoints').limit(1);

                if (error) throw error;
                if (!data || data.length === 0 || !data[0].waypoints || data[0].waypoints.length === 0) {
                     showErrorPanel("No race trail found in the database. Please ask an admin to record one.");
                     return;
                }

                // Store raw waypoints first
                const rawWaypoints = data[0].waypoints;
                console.log(`Trail loaded with ${rawWaypoints.length} waypoints.`);

                 // Create AR entities for each waypoint
                 trailWaypoints = rawWaypoints.map((wp, index) => {
                     const entity = document.createElement('a-entity');
                     entity.setAttribute('id', `waypoint-${index}`);
                     // Use gps-new-entity-place for AR.js v3+
                     entity.setAttribute('gps-new-entity-place', `latitude: ${wp.lat}; longitude: ${wp.lon};`);
                     // Make it always face the camera - good for simple markers/text
                     entity.setAttribute('look-at', '[gps-new-camera]');
                     entity.setAttribute('scale', WAYPOINT_SCALE);
                     entity.setAttribute('visible', 'false'); // Start hidden

                     // Add a visual representation inside the entity
                     const visual = document.createElement('a-box'); // Or a-sphere, a-gltf-model, etc.
                     visual.setAttribute('color', WAYPOINT_COLOR);
                     visual.setAttribute('opacity', '0.8');
                     visual.setAttribute('position', '0 1 0'); // Slightly above ground
                     entity.appendChild(visual);

                     // Add label (optional)
                     const label = document.createElement('a-text');
                     label.setAttribute('value', wp.label || `WP ${index + 1}`);
                     label.setAttribute('look-at', '[gps-new-camera]');
                     label.setAttribute('scale', '5 5 5'); // Adjust text size
                     label.setAttribute('position', '0 2.5 0'); // Position above the visual marker
                     label.setAttribute('align', 'center');
                     entity.appendChild(label);

                     waypointsContainer.appendChild(entity);

                     return { ...wp, entity: entity }; // Store entity reference with waypoint data
                 });


                // Reset race state
                currentWaypointIndex = 0;
                startTime = null; // Timer starts on first location update
                if (timerInterval) clearInterval(timerInterval);
                if (watchId) navigator.geolocation.clearWatch(watchId);

                // Make the first waypoint visible
                if (trailWaypoints.length > 0) {
                    trailWaypoints[0].entity.setAttribute('visible', 'true');
                    updateNextWaypointUI();
                } else {
                    showErrorPanel("Trail data loaded but is empty.");
                    return;
                }

                // Start watching location
                startGeolocationWatch();
                // Orientation listener should already be running from init

                raceStatus.textContent = "Waiting for location...";

            } catch (error) {
                console.error("Error fetching/starting trail:", error);
                showErrorPanel(`Error starting race: ${error.message}`);
            }
        }

        function startTimer() {
             if (startTime) return; // Already started
            startTime = Date.now();
            raceTimerDisplay.textContent = '0.0';
            timerInterval = setInterval(() => {
                if (!startTime) return; // Guard against race ending before interval fires
                const elapsed = (Date.now() - startTime) / 1000;
                raceTimerDisplay.textContent = elapsed.toFixed(1);
            }, 100);
        }

        function stopTimer() {
             if (timerInterval) clearInterval(timerInterval);
             timerInterval = null;
             endTime = Date.now();
             if (startTime) {
                 finalTimeSeconds = (endTime - startTime) / 1000;
             } else {
                 finalTimeSeconds = 0;
             }
             raceTimerDisplay.textContent = finalTimeSeconds.toFixed(1);
             console.log(`Race finished. Time: ${finalTimeSeconds.toFixed(1)}s`);
        }

        function startGeolocationWatch() {
             if (watchId) navigator.geolocation.clearWatch(watchId); // Clear previous if any
             watchId = navigator.geolocation.watchPosition(
                updateUserPosition,
                handleGeolocationError,
                { enableHighAccuracy: true, maximumAge: 2000, timeout: 10000 } // Get frequent updates
             );
             console.log("Geolocation watch started (ID:", watchId, ")");
        }

        function stopGeolocationWatch() {
             if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
                console.log("Geolocation watch stopped.");
             }
        }

        function startOrientationListener() {
             if (orientationListener) return; // Already listening

             if (window.DeviceOrientationEvent) {
                 orientationListener = (event) => {
                    let heading = null;
                    if (event.webkitCompassHeading !== undefined) { // iOS
                        heading = event.webkitCompassHeading;
                    } else if (event.absolute === true && event.alpha !== null) { // Standard
                        heading = (360 - event.alpha); // Adjust alpha
                    }

                    if (heading !== null) {
                        userHeading = heading;
                        updateCompassOverlay();
                        if (SHOW_DEBUG_INFO) updateDebugInfo();
                    }
                 };
                 window.addEventListener('deviceorientation', orientationListener);
                 console.log("Orientation listener added.");
             } else {
                console.warn("DeviceOrientationEvent not supported.");
             }
        }

        function stopOrientationListener() {
             if (orientationListener && window.DeviceOrientationEvent) {
                 window.removeEventListener('deviceorientation', orientationListener);
                 orientationListener = null;
                 console.log("Orientation listener removed.");
             }
        }


        function updateUserPosition(position) {
            startTimer(); // Start timer on the first valid position update
            locationErrorCount = 0; // Reset error count on success
            userLocation = position.coords;
            raceStatus.textContent = `GPS Accuracy: ${userLocation.accuracy.toFixed(1)}m`;
             if (SHOW_DEBUG_INFO) updateDebugInfo();


            if (currentWaypointIndex >= trailWaypoints.length) return; // Race finished

            const nextWpData = trailWaypoints[currentWaypointIndex];
            const distance = calculateDistance(
                userLocation.latitude, userLocation.longitude,
                nextWpData.lat, nextWpData.lon
            );
            distanceDisplay.textContent = distance.toFixed(1);

            // Check if waypoint reached
            if (distance <= WAYPOINT_PROXIMITY_THRESHOLD) {
                 console.log(`Reached waypoint ${currentWaypointIndex + 1}: ${nextWpData.label}`);
                 raceStatus.textContent = `Reached ${nextWpData.label}!`;

                 // Hide current waypoint AR entity
                 nextWpData.entity.setAttribute('visible', 'false');

                 currentWaypointIndex++;

                 if (currentWaypointIndex >= trailWaypoints.length) {
                     // Finished!
                     finishRace();
                 } else {
                     // Make next waypoint visible
                     trailWaypoints[currentWaypointIndex].entity.setAttribute('visible', 'true');
                     updateNextWaypointUI();
                      // Optional feedback
                     try { navigator.vibrate(150); } catch(e) {}
                 }
            }
            // No explicit directional update needed here, AR view handles it.
        }

        function handleGeolocationError(error) {
            console.error("Geolocation watch error:", error);
            raceStatus.textContent = `GPS Error: ${error.message}`;
            locationErrorCount++;
             if (locationErrorCount > MAX_LOCATION_ERRORS) {
                 showErrorPanel(`Too many consecutive GPS errors (${error.message}). Cannot continue race.`);
             }
            if (error.code === 1) { // PERMISSION_DENIED
                showErrorPanel("Location permission denied during race. Cannot continue.");
            }
        }

        function updateNextWaypointUI() {
             if (currentWaypointIndex < trailWaypoints.length) {
                 nextWaypointLabelDisplay.textContent = trailWaypoints[currentWaypointIndex].label || `Waypoint ${currentWaypointIndex + 1}`;
             } else {
                 nextWaypointLabelDisplay.textContent = "Finish!";
             }
             distanceDisplay.textContent = '---'; // Reset distance until next update
        }

         function updateCompassOverlay() {
             if (userHeading !== null) {
                 // Rotate arrow. 0 degrees = North (arrow points up).
                 compassOverlayArrow.style.transform = `rotate(${userHeading}deg)`;
             }
         }

         function updateDebugInfo() {
             if (!SHOW_DEBUG_INFO) return;
             let text = "Debug:\n";
             if (userLocation) {
                 text += `Lat: ${userLocation.latitude.toFixed(5)}\nLon: ${userLocation.longitude.toFixed(5)}\nAcc: ${userLocation.accuracy?.toFixed(1)}m\n`;
             } else { text += "Lat/Lon: N/A\n"; }
             if (userHeading !== null) {
                 text += `Head: ${userHeading.toFixed(1)}°\n`;
             } else { text += "Head: N/A\n"; }
             if (currentWaypointIndex < trailWaypoints.length) {
                  text += `Next WP: ${currentWaypointIndex + 1}`;
             }
             debugInfo.textContent = text;
         }

        function finishRace() {
             console.log("Race Finished!");
             stopTimer();
             stopGeolocationWatch();
             // Keep orientation listener for compass if needed, or stop it:
             // stopOrientationListener();

             // Hide any remaining AR elements (should be none if logic is correct)
             waypointsContainer.innerHTML = ''; // Clear all waypoints

             finalTimeDisplay.textContent = finalTimeSeconds.toFixed(1);
             leaderboardSubmitStatus.textContent = '';
             userNameInput.value = '';
             userEmailInput.value = '';

             showPanel('finish'); // Show first prompt panel
        }

        // Leaderboard Functions (handleJoinLeaderboard, handleSkipPrompt1, handleJoinLeaderboardDiscount, handleSkipPrompt2, saveLeaderboardEntry, showFinalLeaderboard)
        // are identical to the previous version. Ensure they use `supabaseClient` and show/hide the correct UI *panels*.

        function handleJoinLeaderboard() {
             const name = userNameInput.value.trim();
             const email = userEmailInput.value.trim();
             if (!name || !email || !/^\S+@\S+\.\S+$/.test(email)) {
                 leaderboardSubmitStatus.textContent = "Valid name and email required.";
                 return;
             }
             saveLeaderboardEntry(name, email, finalTimeSeconds, leaderboardSubmitStatus, btnJoinLeaderboard, btnJoinLeaderboardDiscount);
        }
        function handleSkipPrompt1() {
             leaderboardSubmitStatusDiscount.textContent = '';
             userNameDiscountInput.value = userNameInput.value;
             userEmailDiscountInput.value = userEmailInput.value;
             showPanel('discountPrompt');
        }
        function handleJoinLeaderboardDiscount() {
             const name = userNameDiscountInput.value.trim();
             const email = userEmailDiscountInput.value.trim();
             if (!name || !email || !/^\S+@\S+\.\S+$/.test(email)) {
                 leaderboardSubmitStatusDiscount.textContent = "Valid name and email required.";
                 return;
             }
             saveLeaderboardEntry(name, email, finalTimeSeconds, leaderboardSubmitStatusDiscount, btnJoinLeaderboard, btnJoinLeaderboardDiscount);
        }
        function handleSkipPrompt2() { showFinalLeaderboard(false); }

        async function saveLeaderboardEntry(name, email, time, statusElement, button1, button2) {
             if (!supabaseClient) { showErrorPanel("Database connection lost."); return; }
             statusElement.textContent = "Saving score...";
             button1.disabled = true; button2.disabled = true;

             try {
                 const { data, error } = await supabaseClient
                     .from('leaderboard').insert([{ name, email, time_in_seconds: time }]);
                 if (error) throw error;
                 console.log("Leaderboard entry saved:", data);
                 showFinalLeaderboard(true); // Indicate user joined
             } catch (error) {
                 console.error("Error saving leaderboard:", error);
                 statusElement.textContent = `Error saving: ${error.message}`;
                  // Show leaderboard anyway after delay
                 setTimeout(() => showFinalLeaderboard(false), 3000);
             } finally {
                  // Re-enable buttons if user stays on the prompt screen after error
                  button1.disabled = false; button2.disabled = false;
             }
        }

        async function showFinalLeaderboard(didJoin) {
             if (!supabaseClient) { showErrorPanel("Database connection lost."); return; }
             finalMessage.textContent = didJoin ? "You're on the leaderboard!" : "Thanks for playing!";
             leaderboardBody.innerHTML = '<tr><td colspan="3">Loading...</td></tr>';
             showPanel('finalLeaderboard');

             try {
                 let { data, error } = await supabaseClient
                     .from('leaderboard').select('name, time_in_seconds')
                     .order('time_in_seconds', { ascending: true }).limit(LEADERBOARD_LIMIT);
                 if (error) throw error;

                 leaderboardBody.innerHTML = ''; // Clear loading
                 if (data && data.length > 0) {
                     data.forEach((entry, index) => {
                         const row = leaderboardBody.insertRow();
                         row.insertCell().textContent = index + 1;
                         row.insertCell().textContent = entry.name ? entry.name.substring(0, 30) : 'Anon';
                         row.insertCell().textContent = parseFloat(entry.time_in_seconds).toFixed(1);
                     });
                 } else {
                     leaderboardBody.innerHTML = '<tr><td colspan="3">Be the first!</td></tr>';
                 }
             } catch (error) {
                 console.error("Error fetching leaderboard:", error);
                 leaderboardBody.innerHTML = `<tr><td colspan="3">Error loading: ${error.message}</td></tr>`;
             }
        }


        /*****************************************
         *        RESET & UTILITY FUNCTIONS      *
         *****************************************/
        function resetToLanding() {
             stopAllActivity();
             // Clear state
             isAdmin = false; recordedWaypoints = []; trailWaypoints = [];
             currentWaypointIndex = 0; userLocation = null; userHeading = null;
             startTime = null; endTime = null; finalTimeSeconds = 0;
             // Clear AR entities
             waypointsContainer.innerHTML = '';
             // Reset UI elements
             adminCodeInput.value = ''; adminLoginError.textContent = '';
             waypointLabelInput.value = ''; updateAdminWaypointList(); adminRecordStatus.textContent = '';
             userNameInput.value = ''; userEmailInput.value = ''; leaderboardSubmitStatus.textContent = '';
             userNameDiscountInput.value = ''; userEmailDiscountInput.value = ''; leaderboardSubmitStatusDiscount.textContent = '';
             // Re-enable potentially disabled buttons
             btnSaveTrail.disabled = true; btnRecordWaypoint.disabled = false;
             btnJoinLeaderboard.disabled = false; btnJoinLeaderboardDiscount.disabled = false;

             // Restart initialization to potentially re-request permissions if needed
             initializeApp();
             // showPanel('landing'); // initializeApp will show landing when ready
        }

         function stopAllActivity() {
             if (timerInterval) clearInterval(timerInterval); timerInterval = null;
             stopGeolocationWatch();
             stopOrientationListener();
             // Stop AR Scene? (Optional)
             // const scene = document.querySelector('a-scene');
             // if (scene && scene.isPlaying) scene.pause();
             console.log("Activity stopped.");
         }

        // MATH FUNCTIONS (calculateDistance, degreesToRadians, radiansToDegrees) - Unchanged
        function degreesToRadians(degrees) { return degrees * Math.PI / 180; }
        function radiansToDegrees(radians) { return radians * 180 / Math.PI; }
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3; const φ1 = degreesToRadians(lat1); const φ2 = degreesToRadians(lat2);
            const Δφ = degreesToRadians(lat2 - lat1); const Δλ = degreesToRadians(lon2 - lon1);
            const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return R * c;
        }


        /*****************************************
         *           EVENT LISTENERS             *
         *****************************************/
        window.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Loaded. Initializing App...");
            initializeApp();

            // --- UI Panel Button Listeners ---
            // Landing
            btnStartUser.addEventListener('click', handleStartUserMode);
            btnAdmin.addEventListener('click', handleAdminClick);
            // Admin Login
            btnAdminSubmit.addEventListener('click', handleAdminLogin);
            btnAdminBack.addEventListener('click', resetToLanding);
            // Admin Record
            btnRecordWaypoint.addEventListener('click', handleRecordWaypoint);
            btnSaveTrail.addEventListener('click', handleSaveTrail);
            btnRecordBack.addEventListener('click', resetToLanding);
            // Finish Prompt 1
            btnJoinLeaderboard.addEventListener('click', handleJoinLeaderboard);
            btnSkipPrompt1.addEventListener('click', handleSkipPrompt1);
            // Finish Prompt 2
            btnJoinLeaderboardDiscount.addEventListener('click', handleJoinLeaderboardDiscount);
            btnSkipPrompt2.addEventListener('click', handleSkipPrompt2);
            // Final Leaderboard
            btnPlayAgain.addEventListener('click', resetToLanding);
            // Error
            btnErrorBack.addEventListener('click', resetToLanding);

            console.log("Event listeners attached.");
        });

        /* Deployment & Setup Notes:
         * 1. Supabase Setup: Use the same table schemas and RLS policies as before.
         * 2. Credentials: Update SUPABASE_URL and SUPABASE_ANON_KEY.
         * 3. Dependencies: This file now REQUIRES A-Frame and AR.js libraries loaded via CDN.
         * 4. Hosting: MUST be served over HTTPS for Camera, Geolocation, and DeviceOrientation APIs to work. GitHub Pages is suitable.
         * 5. Permissions: The app will request Camera, Location, and potentially Motion/Orientation permissions on start. These MUST be granted.
         * 6. Testing: Test thoroughly on target mobile devices. GPS accuracy heavily impacts location-based AR. Performance may vary.
         * 7. Record Trail: Use Admin mode ON LOCATION to record the waypoints accurately.
         * 8. Run Race: Start the race at the designated starting point. Follow the AR markers displayed on screen.
         */
    </script>
</body>
</html>
